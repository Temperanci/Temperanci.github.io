<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>4-24每日</title>
      <link href="/2023/04/24/4-24%E6%AF%8F%E6%97%A5/"/>
      <url>/2023/04/24/4-24%E6%AF%8F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1163-按字典序排在最后的子串"><a href="#1163-按字典序排在最后的子串" class="headerlink" title="1163. 按字典序排在最后的子串"></a>1163. 按字典序排在最后的子串</h1><p>&#x3D;&#x3D;Hard&#x3D;&#x3D;</p><p>给你一个字符串 <code>s</code> ，找出它的所有子串并按字典序排列，返回排在最后的那个子串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abab&quot;输出：&quot;bab&quot;解释：我们可以找出 7 个子串 [&quot;a&quot;, &quot;ab&quot;, &quot;aba&quot;, &quot;abab&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bab&quot;]。按字典序排在最后的子串是 &quot;bab&quot;。</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们注意到，如果一个子串从位置 iii 开始，那么字典序最大的子串一定是 $s[i,..n−1]$，即从位置 $i$ 开始的最长后缀。因此，我们只需要找出字典序最大的后缀子串即可。</p><p>我们使用双指针 $i$ 和 $j$，其中指针 $i$ 指向当前字典序最大的子串的起始位置，指针 $j$ 指向当前考虑的子串的起始位置。另外，用一个变量 $k$ 记录当前比较到的位置。初始时 $i&#x3D;0, j&#x3D;1, k&#x3D;0$。</p><p>每一次，我们比较 $s[i+k]$ 和 $s[j+k]$：</p><p>如果 $s[i+k]&#x3D;s[j+k]$，说明 $s[i,..i+k]$ 和 $s[j,..j+k]$ 相同，我们将 $k$ 加 1，继续比较 $s[i+k]$ 和 $s[j+k]$；</p><p>如果 $s[i+k]&lt;s[j+k]$，说明 $s[j,..j+k]$ 的字典序更大。此时，我们更新 $i&#x3D;i+k+1$，并将 $k$ 重置为 0。如果此时 $i≥j$，那么我们将指针 $j$ 更新为 $i+1$，即 $j&#x3D;i+1$。这里我们跳过了以 $s[i,..,i+k]$ 为起始位置的所有后缀子串，因为它们的字典序一定小于对应的 $s[j,..,j+k]$ 为起始位置的后缀子串。</p><p>同理，如果 $s[i+k]&gt;s[j+k]$，说明 $s[i,..,i+k]$ 的字典序更大。此时，我们更新 $j&#x3D;j+k+1$，并将 $k$ 重置为 0。这里我们跳过了以 $s[j,..,j+k]$ 为起始位置的所有后缀子串，因为它们的字典序一定小于对应的 $s[i,..,i+k]$ 为起始位置的后缀子串。</p><p>最后，我们返回以 $i$ 为起始位置的后缀子串即可，即 $s[i,..,n−1]$。</p><p><a href="https://leetcode.cn/problems/last-substring-in-lexicographical-order/solutions/2242562/python3javacgotypescript-yi-ti-yi-jie-sh-3amj/">https://leetcode.cn/problems/last-substring-in-lexicographical-order/solutions/2242562/python3javacgotypescript-yi-ti-yi-jie-sh-3amj/</a></p><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    string lastSubstring(string s) &#123;        int n = s.size();        int i = 0, j = 1, k = 0;                // 遍历所有可能的子串起始位置 i 和 j        while (j + k < n) &#123;            if (s[i + k] == s[j + k]) &#123;     // 如果相同，则继续比较后面的字符                k++;                continue;            &#125; else if (s[i + k] < s[j + k]) &#123; // 如果 s[i + k] < s[j + k]，i 跳到 j+1，k 置为 0                i += k + 1;                k = 0;                if (i >= j) &#123;               // 如果发现 i 已经超过[j,n)了，就更新 j=i+1                    j = i + 1;                &#125;            &#125; else &#123;                        // 如果 s[i + k] > s[j + k]，j 跳到下一个后缀的起始位置 k+1,j                j += k + 1;                 // 跳到下一个后缀的起点                k = 0;                      // k 重新置为0            &#125;        &#125;        return s.substr(i);                 // 返回最后一个子串    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-23每日</title>
      <link href="/2023/04/23/4-23%E6%AF%8F%E6%97%A5/"/>
      <url>/2023/04/23/4-23%E6%AF%8F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1105-填充书架"><a href="#1105-填充书架" class="headerlink" title="1105. 填充书架"></a>1105. 填充书架</h1><p>给定一个数组 <code>books</code> ，其中 <code>books[i] = [thicknessi, heighti]</code> 表示第 <code>i</code> 本书的厚度和高度。你也会得到一个整数 <code>shelfWidth</code> 。</p><p><strong>按顺序</strong> 将这些书摆放到总宽度为 <code>shelfWidth</code> 的书架上。</p><p>先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 <code>shelfWidth</code> ），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。</p><p>需要注意的是，在上述过程的每个步骤中，<strong>摆放书的顺序与你整理好的顺序相同</strong>。</p><ul><li>例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。</li></ul><p>每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。</p><p>以这种方式布置书架，返回书架整体可能的最小高度。</p><p><strong>示例 1：</strong></p><img src="https://assets.leetcode.com/uploads/2019/06/24/shelves.png" alt="img" style="zoom:50%;" /><pre><code>输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4输出：6解释：3 层书架的高度和为 1 + 3 + 2 = 6 。第 2 本书不必放在第一层书架上。</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然dp。</p><p>对于每本书，我们有两种选择：</p><ol><li>将这本书放在新的一层上；</li><li>将这本书放在当前层上。</li></ol><p>状态转移方程：$dp[i] &#x3D; min(dp[i], dp[j-1] + maxHeight)$</p><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    int minHeightShelves(vector<vector<int>>& books, int shelfWidth) &#123;        int n = books.size();        // 初始化动态规划数组        int dp[n+1];        dp[0] = 0;        for (int i = 1; i <= n; i++) &#123;            // 第一种情况：将当前书放在新的一层上            dp[i] = dp[i-1] + books[i-1][1];              // 第二种情况：将书放在当前层上            int width = books[i-1][0];  // 第 i 本书的宽度            int height = books[i-1][1];     // 第 i 本书的高度                 for (int j = i-1; j > 0 && width + books[j-1][0] <= shelfWidth; j--) &#123;  // 将当前书放在当前层上，从后往前尝试每一本书                height = max(height, books[j-1][1]);  // 找到当前层上所有书籍的最大高度                width += books[j-1][0];// 更新 width 的值                 dp[i] = min(dp[i], dp[j-1] + height);  // 计算当前状态的最小高度            &#125;        &#125;        return dp[n];    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-22美团笔试</title>
      <link href="/2023/04/22/4-22%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/"/>
      <url>/2023/04/22/4-22%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="4-22美团笔试"><a href="#4-22美团笔试" class="headerlink" title="4-22美团笔试"></a>4-22美团笔试</h1><p>19：00 - 21：00 第二个算法题没写出来，估摸着也寄了</p><p>20个专业单选10个应用算术题2个编程题</p><h2 id="1-单选"><a href="#1-单选" class="headerlink" title="1. 单选"></a>1. 单选</h2><ol><li><p><strong>作业调度</strong></p><p>HRRN（Highest Response Ratio Next，最高响应比优先）调度算法是一种用于作业调度的非抢占式算法，是对响应比优先（RR）算法的改进。</p><p>HRRN调度算法中，每个作业的响应比定义为<strong>（等待时间 + 服务时间）&#x2F;服务时间</strong>。当一个作业被放到CPU中运行时，它的响应比将随时发生变化。每当一个作业加入就绪队列时，将对每个作业的响应比计算一次，<strong>并选取响应比最高的作业进行调度。</strong></p></li><li><p><strong>二叉树中序&#x2F;后序遍历</strong></p><p>二叉树遍历是指按照一定的规则对二叉树中的节点进行访问。常用的二叉树遍历方式包括前序遍历、中序遍历和后序遍历。以下是它们的具体定义：</p><ul><li>前序遍历（先序遍历）：先访问根节点，然后访问左子树，最后访问右子树。</li><li>中序遍历：先访问左子树，然后访问根节点，最后访问右子树。</li><li>后序遍历：先访问左子树，然后访问右子树，最后访问根节点。</li></ul></li><li><p><strong>同步请求子进程还是主进程</strong></p><p>在浏览器环境中，同步请求通常是在<strong>主进程</strong>中执行的，而不是在子进程中执行。这是因为主进程是负责整个页面加载和渲染的进程，在执行同步请求时，它会被阻塞，直到请求完成并返回结果。如果同步请求在子进程中执行，那么子进程将会被阻塞，导致页面响应速度变慢，甚至出现假死现象。</p></li><li><p><strong>大数据量高并发如何缓解</strong></p><p>Q：分库分表都可以缓解写入压力吗</p><p>A：分库分表<strong>可以缓解单台MySQL服务器的写入压力，但是并不能完全解决高并发写入压力。</strong>因为在分库分表之后，写入压力是分散到了多台MySQL服务器上，但是每台MySQL服务器上的写入压力仍然可能会很高，会导致单台MySQL服务器的性能瓶颈和故障。分库分表只是将写入压力分散到多台服务器上，从而可以提高系统的并发能力和稳定性，但单台服务器的写入性能仍然可能成为瓶颈。</p><p>Q：数据库分离可以缓解写入压力吗</p><p>A：数据库分离可以缓解写入压力。在数据库分离的情况下，可以将不同的数据和应用程序分布在不同的数据库中，从而减少单个数据库的写入压力，提高整个系统的性能。</p></li><li><p><strong>SQL</strong></p></li><li><p><strong>进程 并发性</strong></p><p>进程的并发性是指<strong>多个进程在同一时间内同时运行的能力</strong>。在计算机系统中，多个进程可以在同一时刻被操作系统调度到不同的 CPU 核心或者处理器中并行执行，从而实现进程的并发性。</p></li><li><p><strong>查找效率</strong></p><p>提高查找效率的方式有很多，主要包括以下几种：</p><ol><li><strong>索引优化</strong>：创建合适的索引，可以大大提高查找效率。索引可以加速数据的查找以及表的连接等操作，如 B+ 树索引、哈希索引、全文索引等。</li><li><strong>分区技术</strong>：在大型数据表中，可以将表根据某个字段进行分区，从而实现数据的快速查找。在进行查询时，只需要对某个分区进行查询即可，而不需要扫描整张表。</li><li><strong>缓存技术</strong>：可以将常用或热门的数据缓存起来，以减少查询次数，提高查询速度，如 Redis、Memcached 等缓存技术。</li><li><strong>搜索引擎</strong>：通过搭建搜索引擎，可以实现全文检索功能，提高查询效率，如 Solr、Elasticsearch 等搜索引擎。</li><li><strong>分布式查询</strong>：在大型数据处理场景下，可以通过分布式查询的方式，将查询请求分散到多个节点上进行处理，提高查询效率，如 Hive、SparkSQL、Hadoop 等大数据处理框架。</li></ol><p>除了上述方式，还可以采用优化 SQL 语句、硬件性能优化、使用缓存或者 NoSQL 数据库等方式来提高查询效率。不同的场景和需求需要不同的优化方式进行结合使用，以满足具体的业务需求。</p></li><li><p><strong>epoll 查找元素的时间复杂度：O(1)</strong></p><p>epoll 是一种<strong>高效的 I&#x2F;O 事件通知机制</strong>，在 Linux 操作系统中被广泛应用于网络编程中，能够有效避免传统 select 和 poll 模型中，随着监听文件描述符数量增多，事件通知效率下降的问题。epoll 的事件管理模型是基于事件触发实现的。它通过 epoll_ctl 将需要监听的 socket 文件描述符注册到 epoll 模型中，再通过 epoll_wait 系统调用来等待这些事件的发生。</p><p>epoll 的<strong>时间复杂度是 O(1)<strong>，因为它用</strong>红黑树</strong>来存储文件描述符，而红黑树具有对数时间复杂度 O(logn) 的特点，它可以在一些比较大的 file descriptor 中快速定位到要处理的事件，而不需要轮询，因此效率高于 select 和 poll 模型。</p><p>综上所述，epoll 作为一种高效的 I&#x2F;O 事件通知机制，它具有时间复杂度低、高效性强、可扩展性好的特点，被广泛应用于大规模高并发的网络编程中。</p></li><li><p><strong>BFS</strong></p><p><strong>BFS（Breadth First Search），又称广度优先搜索</strong>，是从起始点开始逐层扫描整张图，先一层一层搜索，直到找到目标点为止。在搜索过程中，使用一个队列来保存每一层的所有节点，先进先出，逐层递进，直到搜索到目标节点为止。BFS 的时间复杂度为 O(|V|+|E|)，其中 |V| 表示节点个数，|E| 表示边数。</p><p><strong>DFS（Depth First Search），又称深度优先搜索</strong>，是从起始点开始一直往深处搜索，直到找到目标节点为止。在搜索过程中，从起始节点开始，递归地搜索它的相邻节点，每次只选择其中一个节点继续深入，直到找到目标节点或者没有相邻节点为止。DFS 的时间复杂度为 O(|V|+|E|)，其中 |V| 表示节点个数，|E| 表示边数。</p><p>BFS 和 DFS 都有各自的优缺点，在不同的应用场景中可以选择不同的算法。<strong>BFS 算法可以找到最短路径</strong>，但是需要占用大量的存储空间，其空间复杂度为 O(|V|)，<strong>当图中节点较多时，空间开销较大</strong>；<strong>DFS 算法则可以快速地搜索整张图，但是不能一定找到最短路径</strong>，<strong>存在搜索深度较深时容易陷入死循环的问题</strong>。因此，在实际应用中，需要综合考虑应用场景、搜索结果等的优缺点进行选择。</p></li><li><p><strong>适配器模式本质</strong></p><p>适配器模式的本质是<strong>将一个已有的接口转化为另一个客户端所需要的接口，以适应不同的环境和需求</strong>。它属于结构型设计模式，可以在不改变接口前提下，将原始接口转换为目标接口，使得不兼容的类可以一起工作。</p><p>适配器模式的主要作用是<strong>提高代码的复用性和可扩展性</strong>。</p></li><li><p><strong>递归成立的条件</strong></p><p>递归需要满足以下两个条件才能实现：</p><ol><li><strong>递归调用</strong>：在函数体内直接或间接地调用自身。</li><li><strong>结束条件</strong>：在递归调用的过程中，一定要存在一个条件，当满足这个条件时，递归调用停止，从而结束递归。</li></ol></li><li><p><strong>SQL</strong></p></li><li><p><strong>图</strong></p><p><strong>连通图</strong>是指无向图或有向图中，<strong>任意两个顶点之间都存在一条路径</strong>，也就是说图中的任意两个顶点都是连通的。无向图中的连通图也被称为连通分量。如果一个无向图有 k 个连通分量，则该图的连通性为 k。</p><p><strong>不连通图</strong>是指无向图或有向图中，<strong>存在某些顶点之间没有直接相连的路径</strong>，也就是说图中有些顶点是不连通的。无向图中，不连通的部分可以被视为若干个由连通部分组成的图，每个连通部分都是一个连通分量。</p></li><li><p><strong>水题</strong></p></li><li><p><strong>表字段 NULL</strong></p><p>非空是 NOT NULL</p></li><li><p><strong>ARP协议 单播 广播</strong></p><p>ARP（Address Resolution Protocol）是用于将IP地址转换为MAC地址的协议，常用于局域网中。在ARP请求中，主机会向网络中的所有主机广播ARP请求，以获取某个IP地址对应的MAC地址。因此，ARP协议接收时是广播的。</p></li><li><p><strong>辗转相除</strong></p></li><li><p><strong>信号量可用资源</strong></p><p>当前信号量表示目前剩余资源，临界区 &#x3D; 总信号量 - 当前信号量，等待 &#x3D; 待处理信号 - 剩余资源</p></li><li><p><strong>GDB打印元素</strong></p><p>GDB（GNU Debugger）是一种功能强大的调试器，是 GNU 软件开发工具集的一部分。</p></li><li><p><strong>IMAP协议</strong></p><p>IMAP（Internet Message Access Protocol，互联网邮件访问协议）是一个用于从邮件服务器上获取邮件的标准协议。</p><p>IMAP协议的主要功能是让客户端可以直接在邮件服务器上管理邮件，有如下主要特点：</p><ol><li><strong>支持多个客户端同时访问同一个邮箱</strong>，比POP3更加适合多设备使用，如手机、平板、笔记本等。</li><li><strong>支持在线邮件阅读</strong>，可实现邮件在服务器上的搜索、筛选、排序等高级功能。</li><li><strong>支持邮件的部分下载</strong>，节省网络流量，提高效率。</li><li>通过IMAP客户端，可以在邮件服务器上创建、删除、移动邮件，比POP3更加强大和灵活。</li><li>IMAP协议和邮件本身的数据结构更加复杂，需要在服务器上消耗更多的资源和时间，因此需要更高的硬件配置。</li><li>支持通过字符串搜索邮件内容。</li></ol><p>IMAP协议在电子邮件传输和管理中扮演着重要的角色，具有更丰富的功能和更强的灵活性，也成为了当前比较流行的邮件协议。</p></li></ol><h2 id="2-算法题"><a href="#2-算法题" class="headerlink" title="2. 算法题"></a>2. 算法题</h2><h3 id="1-计算水题"><a href="#1-计算水题" class="headerlink" title="1. 计算水题"></a>1. 计算水题</h3><p>好久没写 C++ 了，要注意多个变量初始化的时候记得分开写。</p><p>√：</p><pre><code>double up = 0, down = 0;</code></pre><p>X：</p><pre><code>double up, down = 0;</code></pre><p>写 js 写习惯了是这样的。</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;int point[2000];int score[2000];int main()&#123;  int T;  scanf ("%d", &T);  while (T--) &#123;    int n, x = 0;    scanf("%d%d", &n, &x);    for (int i = 0; i < n; ++i) &#123;        scanf ("%d", &point[i]);    &#125;    for (int i = 0; i < n; ++i) &#123;        scanf ("%d", &score[i]);    &#125;    bool flag;    flag = true;    double up = 0, down = 0;    for (int i = 0; i < n; ++i) &#123;        if (score[i] < 60) &#123;            flag = false;            break;        &#125;    &#125;    if (flag == false) &#123;        printf("No\n");        continue;    &#125;    for (int i = 0; i < n; ++i) &#123;        up += point[i] * score[i];        down += point[i];    &#125;    double res = up / down;    if (res >= x) &#123;        printf("Yes\n");        continue;    &#125; else &#123;        printf("No\n");    &#125;  &#125;;  return 0;&#125;</code></pre><h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2. 完全背包问题"></a>2. 完全背包问题</h3><p>n种作物，m的时间，接下来三行</p><p>第一行t，表示每种作物成熟所需时间</p><p>第二行a，表示作物成本</p><p>第三行b，表示卖出作物的价格</p><p>输出最大收益</p><p>c[i]&#x3D;b[i]-a[i]表示单一作物的收益</p><p>f[i][j]表示可以选择前i种作物，总时间为j的情况下的最优解</p><p>f[n] [m]&#x3D;&#x3D;&gt;最终结果</p><p>f[ 0 ] [j]&#x3D;0<br>f[i][0]&#x3D;0</p><p>状态转移方程<br>f[i][j]&#x3D;max(f [ i - 1 ] [ j ],c[i]+f[i][j-t[i]])</p><p>计算第i行的时候，确定的是第i种作物种几个<br>决策：0&#x2F;101背包<br>    k完全背包</p><p>for i&#x3D;1..n<br>    for j&#x3D;1..m<br>        f[i][j]&#x3D;k* c[i]+f[ i-1 ] [j-k * t[i]]</p><p>把第三次循环的 k 优化掉了，原因是不需要计算同一行前一个已经计算过的冗余部分，直接拿前一个的计算结果即可，因为前面计算过的已经找到了最优的解。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre class=" language-C++"><code class="language-C++">#include <iostream>using namespace std;int main() &#123;    int n, V;    cin >> n >> V;    int w[n+1], v[n+1];    for (int i = 1; i <= n; i++) &#123;        cin >> w[i] >> v[i];    &#125;    int dp[V+1];    memset(dp, 0, sizeof(dp));    for (int i = 1; i <= n; i++) &#123;        for (int j = w[i]; j <= V; j++) &#123;            dp[j] = max(dp[j], dp[j-w[i]] + v[i]);        &#125;    &#125;    cout << dp[V] << endl;    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-22每日</title>
      <link href="/2023/04/22/4-22%E6%AF%8F%E6%97%A5/"/>
      <url>/2023/04/22/4-22%E6%AF%8F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1027-最长等差数列"><a href="#1027-最长等差数列" class="headerlink" title="1027. 最长等差数列"></a>1027. 最长等差数列</h1><p>给你一个整数数组 <code>nums</code>，返回 <code>nums</code> 中最长等差子序列的<strong>长度</strong>。</p><p>回想一下，<code>nums</code> 的子序列是一个列表 <code>nums[i1], nums[i2], ..., nums[ik]</code> ，且 <code>0 &lt;= i1 &lt; i2 &lt; ... &lt; ik &lt;= nums.length - 1</code>。并且如果 <code>seq[i+1] - seq[i]</code>( <code>0 &lt;= i &lt; seq.length - 1</code>) 的值都相同，那么序列 <code>seq</code> 是等差的。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,6,9,12]输出：4解释： 整个数组是公差为 3 的等差数列。</code></pre><h2 id="题解：dp"><a href="#题解：dp" class="headerlink" title="题解：dp"></a>题解：dp</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * @param &amp;#123;number[]&amp;#125; nums * @return &amp;#123;number&amp;#125; */</span><span class="token keyword">var</span> longestArithSeqLength <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化 dp 数组，每个位置对应一个哈希表，用于存储以该位置为结尾、以其差值为公差的等差数列的长度</span>    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化结果为 2，因为任意两个数都是等差数列</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 枚举等差数列的最后一项</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 枚举等差数列的倒数第二项</span>            <span class="token keyword">const</span> d <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 计算等差数列的差值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果 dp[i] 中存在该差值</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 转移，更新以 nums[j] 结尾、以差值 d 为公差的等差数列的长度为 dp[i].get(d) + 1</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果 dp[i] 中不存在该差值</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化以 nums[j], nums[i] 为首尾、以差值 d 为公差的等差数列的长度为 2</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 更新全局最长等差子序列的长度 res</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回最长等差数列的长度</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-21每日</title>
      <link href="/2023/04/21/4-21%E6%AF%8F%E6%97%A5/"/>
      <url>/2023/04/21/4-21%E6%AF%8F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="2413-最小偶倍数"><a href="#2413-最小偶倍数" class="headerlink" title="2413. 最小偶倍数"></a>2413. 最小偶倍数</h1><p>给你一个正整数 <code>n</code> ，返回 <code>2</code> 和 <code>n</code> 的最小公倍数（正整数）。</p><p> <strong>示例 1：</strong></p><pre><code>输入：n = 5输出：10解释：5 和 2 的最小公倍数是 10 。</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>休闲</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * @param &amp;#123;number&amp;#125; n * @return &amp;#123;number&amp;#125; */</span><span class="token keyword">var</span> smallestEvenMultiple <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-20每日</title>
      <link href="/2023/04/20/4-20%E6%AF%8F%E6%97%A5/"/>
      <url>/2023/04/20/4-20%E6%AF%8F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1187-使数组严格递增"><a href="#1187-使数组严格递增" class="headerlink" title="1187. 使数组严格递增"></a>1187. 使数组严格递增</h1><p>给你两个整数数组 <code>arr1</code> 和 <code>arr2</code>，返回使 <code>arr1</code> 严格递增所需要的最小「操作」数（可能为 0）。</p><p>每一步「操作」中，你可以分别从 <code>arr1</code> 和 <code>arr2</code> 中各选出一个索引，分别为 <code>i</code> 和 <code>j</code>，<code>0 &lt;= i &lt; arr1.length</code> 和 <code>0 &lt;= j &lt; arr2.length</code>，然后进行赋值运算 <code>arr1[i] = arr2[j]</code>。</p><p>如果无法让 <code>arr1</code> 严格递增，请返回 <code>-1</code>。</p><p><strong>示例 1：</strong></p><pre><code>输入：arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]输出：1解释：用 2 来替换 5，之后 arr1 = [1, 2, 3, 6, 7]。</code></pre><h2 id="题解：动态规划"><a href="#题解：动态规划" class="headerlink" title="题解：动态规划"></a>题解：动态规划</h2><p>首先需要将 arr2 排序去重，并记为 list。</p><p>定义 dp[i] [j] 表示对于 arr1 的前 i 个元素，且替换了 j 个元素之后，序列的末尾数字的最小值。</p><p>将 dp 数组初始化，对于 dp[0] [0]，为了方便后面的转移，其值设为 -1。</p><p>对于 dp[i] [j]，有以下几种情况：</p><ul><li>如果当前 arr1[i-1] 大于 dp[ i-1] [j]，说明不用替换，直接添加 arr1[ i-1]。</li><li>如果 j &gt; 0，且 dp[ i-1] [ j-1] 不为 INF，说明可以选择替换掉前面的某个数字，使得后面更容易增加。此时找到 list 中大于 dp[ i-1] [ j-1] 的最小值进行替换。</li><li>如果 i &#x3D;&#x3D; n 且 dp[i] [j] 不为 INF，说明已经处理完所有元素且序列严格递增，直接返回 j。</li></ul><p>最终返回如果需要替换的次数，即为 dp[n] [j] 中最小不为 INF 的 j 值。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> INF <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">var</span> makeArrayIncreasing <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    arr2<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 arr2 排序</span>    <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> prev <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> num <span class="token keyword">of</span> arr2<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 去重</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">!==</span> prev<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            prev <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">const</span> m <span class="token operator">=</span> list<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>INF<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化 dp 数组</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 为了方便后面的转移，设 dp[0][0] = -1</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果当前元素大于序列的最后一个元素</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!==</span> INF<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果可以进行替换操作</span>                <span class="token keyword">const</span> idx <span class="token operator">=</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 查找严格大于 dp[i - 1][j - 1] 的最小元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">!==</span> list<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> n <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!==</span> INF<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果已经处理完所有元素且序列严格递增，直接返回替换次数</span>                <span class="token keyword">return</span> j<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果无法使 arr1 严格递增，返回 -1</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">const</span> binarySearch <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token punctuation">,</span> low<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> high <span class="token operator">=</span> list<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 二分查找</span>        <span class="token keyword">const</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            high <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-19每日</title>
      <link href="/2023/04/19/4-19%E6%AF%8F%E6%97%A5/"/>
      <url>/2023/04/19/4-19%E6%AF%8F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1043-分隔数组以得到最大和"><a href="#1043-分隔数组以得到最大和" class="headerlink" title="1043. 分隔数组以得到最大和"></a>1043. 分隔数组以得到最大和</h1><p>给你一个整数数组 <code>arr</code>，请你将该数组分隔为长度 <strong>最多</strong> 为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。</p><p>返回将数组分隔变换后能够得到的元素最大和。本题所用到的测试用例会确保答案是一个 32 位整数。</p><p><strong>示例 1：</strong></p><pre><code>输入：arr = [1,15,7,9,2,5,10], k = 3输出：84解释：数组变为 [15,15,15,9,10,10,10]</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先通过动态规划预处理出位置 <code>i</code> 前的一个子区间的最大值，即 <code>max</code>，再利用动态规划求出位置 <code>i</code> 的最优解，即将位置 <code>i</code> 之前分成一个长度为 <code>j</code> 的区间和一个长度为 <code>i - j</code> 的区间，前者的最大值即为 <code>max</code>。随着不断前进，将得到整个数组的解。注意在第二层循环中，我们需要设置 j 的起点，也就是确保至少一次划分，以方便初始化 dp[1~k]，也就是最开始为 arr[0], arr[0] * 2, arr[0] * 3, …。时间复杂度为 $O(n^2)$。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> maxSumAfterPartitioning <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dp[i] 表示将前 i 个元素分隔变换后能够得到的元素最大和</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 遍历每个位置</span>        <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化最大值</span>        <span class="token keyword">const</span> deque <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义一个单调队列</span>        <span class="token comment" spellcheck="true">// 从右到左遍历前 i 个元素，找出长度不超过 k 的子数组的最大值</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">-</span> j <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            deque<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将最大值加入队列头部</span>            <span class="token keyword">const</span> length <span class="token operator">=</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 子数组长度为 i-j</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果子数组长度为 1，直接使用该元素的值进行赋值</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 否则，使用最大值乘以当前长度与 dp[j] 中的较大值进行赋值</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> deque<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> length <span class="token operator">+</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 dp[n] 即为答案</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-18每日</title>
      <link href="/2023/04/18/4-18%E6%AF%8F%E6%97%A5/"/>
      <url>/2023/04/18/4-18%E6%AF%8F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1026-节点与其祖先之间的最大差值"><a href="#1026-节点与其祖先之间的最大差值" class="headerlink" title="1026. 节点与其祖先之间的最大差值"></a>1026. 节点与其祖先之间的最大差值</h1><p>给定二叉树的根节点 <code>root</code>，找出存在于 <strong>不同</strong> 节点 <code>A</code> 和 <code>B</code> 之间的最大值 <code>V</code>，其中 <code>V = |A.val - B.val|</code>，且 <code>A</code> 是 <code>B</code> 的祖先。</p><p>（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/09/tmp-tree.jpg" alt="img"></p><pre><code>输入：root = [8,3,10,1,6,null,14,null,null,4,7,13]输出：7解释： 我们有大量的节点与其祖先的差值，其中一些如下：|8 - 3| = 5|3 - 7| = 4|8 - 1| = 7|10 - 13| = 3在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> maxAncestorDiff <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         V<span class="token punctuation">:</span> <span class="token number">0</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 记录最大差值</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">.</span>V<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> result<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> max<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">,</span> min<span class="token punctuation">:</span> <span class="token number">Infinity</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> max<span class="token punctuation">:</span> maxLeft<span class="token punctuation">,</span> min<span class="token punctuation">:</span> minLeft <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 左子节点的最大值和最小值</span>    <span class="token keyword">let</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> max<span class="token punctuation">:</span> maxRight<span class="token punctuation">,</span> min<span class="token punctuation">:</span> minRight <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 右子节点的最大值和最小值</span>        <span class="token comment" spellcheck="true">// 计算当前节点子树中的最大值和最小值</span>    <span class="token keyword">let</span> maxVal <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> maxLeft<span class="token punctuation">,</span> maxRight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> minVal <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> minLeft<span class="token punctuation">,</span> minRight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 更新最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> diff <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> minLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> result<span class="token punctuation">.</span>V<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span>V <span class="token operator">=</span> diff<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        diff <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> maxLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> result<span class="token punctuation">.</span>V<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span>V <span class="token operator">=</span> diff<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> diff <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> minRight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> result<span class="token punctuation">.</span>V<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span>V <span class="token operator">=</span> diff<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        diff <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> maxRight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> result<span class="token punctuation">.</span>V<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span>V <span class="token operator">=</span> diff<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> max<span class="token punctuation">:</span> maxVal<span class="token punctuation">,</span> min<span class="token punctuation">:</span> minVal <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>如果直接使用 <code>result = 0</code> 来初始化结果，则会导致 <code>result</code> 存储的是一个数字，而不是一个对象。这样在 DFS 遍历过程中，我们无法直接修改 <code>result</code> 的值，而需要额外声明一个变量来保存最大差值。具体来说，我们需要在递归函数的返回值中返回最大差值，然后在计算当前节点的最大差值时，将递归返回的最大差值和当前节点的差值进行比较，取两者中的较大值作为新的最大差值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-17每日</title>
      <link href="/2023/04/17/4-17%E6%AF%8F%E6%97%A5/"/>
      <url>/2023/04/17/4-17%E6%AF%8F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="2409-统计共同度过的日子数"><a href="#2409-统计共同度过的日子数" class="headerlink" title="2409. 统计共同度过的日子数"></a>2409. 统计共同度过的日子数</h1><p>Alice 和 Bob 计划分别去罗马开会。</p><p>给你四个字符串 <code>arriveAlice</code> ，<code>leaveAlice</code> ，<code>arriveBob</code> 和 <code>leaveBob</code> 。Alice 会在日期 <code>arriveAlice</code> 到 <code>leaveAlice</code> 之间在城市里（<strong>日期为闭区间</strong>），而 Bob 在日期 <code>arriveBob</code> 到 <code>leaveBob</code> 之间在城市里（<strong>日期为闭区间</strong>）。每个字符串都包含 5 个字符，格式为 <code>&quot;MM-DD&quot;</code> ，对应着一个日期的月和日。</p><p>请你返回 Alice和 Bob 同时在罗马的天数。</p><p>你可以假设所有日期都在 <strong>同一个</strong> 自然年，而且 <strong>不是</strong> 闰年。每个月份的天数分别为：<code>[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：arriveAlice = &quot;08-15&quot;, leaveAlice = &quot;08-18&quot;, arriveBob = &quot;08-16&quot;, leaveBob = &quot;08-19&quot;输出：3解释：Alice 从 8 月 15 号到 8 月 18 号在罗马。Bob 从 8 月 16 号到 8 月 19 号在罗马，他们同时在罗马的日期为 8 月 16、17 和 18 号。所以答案为 3 。</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>主要还是输入处理的问题，将日期字符串分割，然后处理为日期数。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * @param &amp;#123;string&amp;#125; arriveAlice * @param &amp;#123;string&amp;#125; leaveAlice * @param &amp;#123;string&amp;#125; arriveBob * @param &amp;#123;string&amp;#125; leaveBob * @return &amp;#123;number&amp;#125; */</span><span class="token keyword">const</span> monthDays <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> countDaysTogether <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arriveAlice<span class="token punctuation">,</span> leaveAlice<span class="token punctuation">,</span> arriveBob<span class="token punctuation">,</span> leaveBob<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用数组 `sum` 存储每个月的天数累加和</span>    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> monthDays<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        sum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> monthDays<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分别计算两个人到达日期和离开日期的天数</span>    <span class="token keyword">let</span> aA <span class="token operator">=</span> <span class="token function">calc</span><span class="token punctuation">(</span>arriveAlice<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> lA <span class="token operator">=</span> <span class="token function">calc</span><span class="token punctuation">(</span>leaveAlice<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> aB <span class="token operator">=</span> <span class="token function">calc</span><span class="token punctuation">(</span>arriveBob<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> lB <span class="token operator">=</span> <span class="token function">calc</span><span class="token punctuation">(</span>leaveBob<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据到达和离开日期的天数计算旅行天数，即两个时间段的重合部分</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>lA<span class="token punctuation">,</span> lB<span class="token punctuation">)</span> <span class="token operator">-</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>aA<span class="token punctuation">,</span> aB<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 计算日期所对应的天数</span><span class="token keyword">function</span> <span class="token function">calc</span><span class="token punctuation">(</span>day<span class="token punctuation">,</span> sum<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> month <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>day<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> date <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>day<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sum<span class="token punctuation">[</span>month <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> date<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.15米哈游笔试</title>
      <link href="/2023/04/15/4-15%E7%B1%B3%E5%93%88%E6%B8%B8%E7%AC%94%E8%AF%95/"/>
      <url>/2023/04/15/4-15%E7%B1%B3%E5%93%88%E6%B8%B8%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="4-15-米哈游笔试"><a href="#4-15-米哈游笔试" class="headerlink" title="4.15 米哈游笔试"></a>4.15 米哈游笔试</h1><p>20:00 - 22:00 看起来基本是寄了</p><p>10个单选  10个不定项选择  3个算法题</p><p>选择题涉及：进程线程、TCP&#x2F;UDP、js 原型，resolve，输入输出，css flex模型</p><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>首先我不熟悉输入输出，在这个 ACM 的界面磨蹭了半天才开始写，有点抽象</p><p>然后后面就基本没时间写了</p><h3 id="1-正整数"><a href="#1-正整数" class="headerlink" title="1. 正整数"></a>1. 正整数</h3><p>给一个偶数位正整数，分割成两部分后求和，求和的最小值。</p><p>例如输入4321，输出64。</p><p>思路基本上是从中间切，或者中间的+1-1位置切</p><p>但是从中间切就过了85%了，乐</p><h3 id="2-反应"><a href="#2-反应" class="headerlink" title="2. 反应"></a>2. 反应</h3><p>给一个 n * m 的矩形，格子内随机存在 T 和 I，如果 T 和 I 处在相邻位置（上下左右）会反应。</p><p>输出反应后的矩形</p><pre><code>输入：3 4T I T .. . . I. T . I输出：. . . .. . . I. T . I</code></pre><p>思路就是遍历，然后看上下左右有没有相反的元素，开一个新布尔数组用于记录该位置有没有反应，先全值为 false，反应了就置 true。最后再遍历一遍统一处理输出。</p><h3 id="3-猜数组"><a href="#3-猜数组" class="headerlink" title="3. 猜数组"></a>3. 猜数组</h3><p>有两个数组 a 和 b，遵循以下规律：</p><ul><li>$b_i &#x3D; a_i + a_{i+1}$</li><li><code>a.length = b.length + 1</code></li><li>a 数组的元素均为正整数</li></ul><p>给你 a 数组的长度和 b 数组，返回 a 数组所有可能的情况的数量。</p><pre><code>输入：33 4输出：2解释：数组 a 有可能是[1,2,2]或[2,1,3],共两种情况，故返回2.</code></pre><h4 id="思路：寻找-a-0-的大小范围即可"><a href="#思路：寻找-a-0-的大小范围即可" class="headerlink" title="思路：寻找 $a_0$ 的大小范围即可"></a>思路：寻找 $a_0$ 的大小范围即可</h4><p>因为 a 数组的元素均为正整数，所以显然 b 数组的元素也都是正整数。</p><p>当 $a_0$ 确定了，后面的数字也就跟着确定了，于是问题转化为确定 $a_0$ 的范围。</p><p>从 $a_i &gt; 0$ 着手：因为 $b_i &#x3D; a_i + a_{i+1}$ ，所以可以举例：</p><ul><li><p>首先，$a_0 &gt;0$ ；</p></li><li><p>$i&#x3D;0$ 时， $b_0 &#x3D; a_0 + a_{1}$， &#x3D;&gt; $a_1 &#x3D; b_0 - a_0$ ，因为 $a_1 &gt; 0$ ，&#x3D;&gt; $b_0-a_0&gt;0$ ，&#x3D;&gt; $a_0 &lt; b_0$ 。</p><p>因为已经知道 $b_0$ 的值，所以此时 $0&lt;a_0&lt;b_0$ 。</p></li><li><p>$i&#x3D;1$ 时，可以得到 $a_0 &gt; -b_1+b_0$ ；</p></li><li><p>$i&#x3D;2$ 时，可以得到 $a_0 &lt; b_2 -b_1+b_0$ ；</p></li><li><p>$i&#x3D;3$ 时，可以得到 $a_0 &gt; b_3 + b_2 -b_1+b_0$ ；</p></li></ul><p>至此得到规律，当处理到 b 数组的偶数位时，限制的是 $a_0$ 的上限；当处理到 b 数组的奇数位时，限制的是 $a_0$ 的下限。</p><p>所以只需要从头开始遍历 b 数组，取两个数 max、min 为上下限，当处理到奇数位时如果大于min则更新，当处理到偶数为时如果小于max则更新。特殊情况，若 max &lt; min 则返回0。</p><p>最后返回 max - min - 1 即可（因为 $a_0$ 的取值范围是 (min, max)，即从 min+1 到 max-1的数字的数量）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-15每日</title>
      <link href="/2023/04/15/4-15%E6%AF%8F%E6%97%A5/"/>
      <url>/2023/04/15/4-15%E6%AF%8F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1042-不邻接植花"><a href="#1042-不邻接植花" class="headerlink" title="1042. 不邻接植花"></a>1042. 不邻接植花</h1><p>有 <code>n</code> 个花园，按从 <code>1</code> 到 <code>n</code> 标记。另有数组 <code>paths</code> ，其中 <code>paths[i] = [xi, yi]</code> 描述了花园 <code>xi</code> 到花园 <code>yi</code> 的双向路径。在每个花园中，你打算种下四种花之一。</p><p>另外，所有花园 <strong>最多</strong> 有 <strong>3</strong> 条路径可以进入或离开.</p><p>你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。</p><p><em>以数组形式返回 <strong>任一</strong> 可行的方案作为答案 <code>answer</code>，其中 <code>answer[i]</code> 为在第 <code>(i+1)</code> 个花园中种植的花的种类。花的种类用  1、2、3、4 表示。保证存在答案。</em></p><p><strong>示例 1：</strong></p><pre><code>输入：n = 3, paths = [[1,2],[2,3],[3,1]]输出：[1,2,3]解释：花园 1 和 2 花的种类不同。花园 2 和 3 花的种类不同。花园 3 和 1 花的种类不同。因此，[1,2,3] 是一个满足题意的答案。其他满足题意的答案有 [1,2,4]、[1,4,2] 和 [3,2,1]</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * @param &amp;#123;number&amp;#125; n 花园的数量 * @param &amp;#123;number[][]&amp;#125; paths 花园之间的路径列表 * @return &amp;#123;number[]&amp;#125; 返回一个长度为 n 的数组，代表每个花园所涂的颜色 */</span><span class="token keyword">var</span> gardenNoAdj <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> paths<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造邻接表，用 nei[i] 存储与第 i 个花园相邻的花园编号</span>    <span class="token keyword">let</span> nei <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> path <span class="token keyword">of</span> paths<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        nei<span class="token punctuation">[</span>path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nei<span class="token punctuation">[</span>path<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化结果数组 res，用 res[i] 存储第 i 个花园所涂的颜色</span>    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历每个花园，对其进行着色</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> usedColor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化 usedColor，用于记录相邻花园已经使用的颜色</span>        <span class="token comment" spellcheck="true">// 遍历第 i 个花园的相邻花园，统计已经使用的颜色</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> vertex <span class="token keyword">of</span> nei<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            usedColor<span class="token punctuation">[</span>res<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 找到第一个未使用的颜色</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>usedColor<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n+m)，其中 n 表示花园的数目，m 表示 paths 的数目。由于题目中每个花园的邻接节点数目不超过 3 个，因此每个节点的边不超过 3 条，所以遍历所有的节点与所有的边需要的总的时间不超过 O(m+n)。</p><p>空间复杂度：O(n+m)，其中 n 表示花园的数目，m 表示 paths 的数目。需要存储每个节点的邻接节点，总共需要的空间为 O(n+m)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-14每日</title>
      <link href="/2023/04/14/4-14%E6%AF%8F%E6%97%A5/"/>
      <url>/2023/04/14/4-14%E6%AF%8F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1023-驼峰式匹配"><a href="#1023-驼峰式匹配" class="headerlink" title="1023. 驼峰式匹配"></a>1023. 驼峰式匹配</h1><p>如果我们可以将<strong>小写字母</strong>插入模式串 <code>pattern</code> 得到待查询项 <code>query</code>，那么待查询项与给定模式串匹配。（我们可以在任何位置插入每个字符，也可以插入 0 个字符。）</p><p>给定待查询列表 <code>queries</code>，和模式串 <code>pattern</code>，返回由布尔值组成的答案列表 <code>answer</code>。只有在待查项 <code>queries[i]</code> 与模式串 <code>pattern</code> 匹配时， <code>answer[i]</code> 才为 <code>true</code>，否则为 <code>false</code>。</p><p><strong>示例 1：</strong></p><pre><code>输入：queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;输出：[true,false,true,true,false]示例：&quot;FooBar&quot; 可以这样生成：&quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;。&quot;FootBall&quot; 可以这样生成：&quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * @param &amp;#123;string[]&amp;#125; queries * @param &amp;#123;string&amp;#125; pattern * @return &amp;#123;boolean[]&amp;#125; */</span><span class="token keyword">var</span> camelMatch <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>queries<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queries <span class="token operator">||</span> queries<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queries<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span>queries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">match</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token operator">++</span>j<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 若str出现在pattern中不存在的大写字母，则直接返回false</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token string">'A'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token string">'Z'</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> j <span class="token operator">===</span> pattern<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.13每日</title>
      <link href="/2023/04/13/4-13%E6%AF%8F%E6%97%A5/"/>
      <url>/2023/04/13/4-13%E6%AF%8F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="2404-出现最频繁的偶数元素"><a href="#2404-出现最频繁的偶数元素" class="headerlink" title="2404. 出现最频繁的偶数元素"></a>2404. 出现最频繁的偶数元素</h1><p>给你一个整数数组 <code>nums</code> ，返回出现最频繁的偶数元素。</p><p>如果存在多个满足条件的元素，只需要返回 <strong>最小</strong> 的一个。如果不存在这样的元素，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [0,1,2,2,4,4,1]输出：2解释：数组中的偶数元素为 0、2 和 4 ，在这些元素中，2 和 4 出现次数最多。返回最小的那个，即返回 2 。</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mostFrequentEven</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个Map对象</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> x <span class="token keyword">of</span> nums<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 遍历数组中的每个数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 判断该数是否为偶数</span>      cnt<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span>cnt<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将偶数x和对应的出现次数加入Map中</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化结果为-1</span>  <span class="token keyword">let</span> mx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化最大出现次数为0</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token keyword">of</span> cnt<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 遍历Map中的所有键值对</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mx <span class="token operator">&lt;</span> v <span class="token operator">||</span> <span class="token punctuation">(</span>mx <span class="token operator">===</span> v <span class="token operator">&amp;&amp;</span> ans <span class="token operator">></span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果当前偶数出现的次数更多，或者两个偶数的出现次数相等，但是x更小，则更新ans和mx</span>      ans <span class="token operator">=</span> x<span class="token punctuation">;</span>      mx <span class="token operator">=</span> v<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回出现次数最多的偶数</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>段式回文</title>
      <link href="/2023/04/12/%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87/"/>
      <url>/2023/04/12/%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="1147-段式回文"><a href="#1147-段式回文" class="headerlink" title="1147. 段式回文"></a>1147. 段式回文</h2><p>你会得到一个字符串 <code>text</code> 。你应该把它分成 <code>k</code> 个子字符串 <code>(subtext1, subtext2，…， subtextk)</code> ，要求满足:</p><ul><li><code>subtexti</code> 是 <strong>非空</strong> 字符串</li><li>所有子字符串的连接等于 <code>text</code> ( 即<code>subtext1 + subtext2 + ... + subtextk == text</code> )</li><li>对于所有 i 的有效值( 即 <code>1 &lt;= i &lt;= k</code> ) ，<code>subtexti == subtextk - i + 1</code> 均成立</li></ul><p>返回<code>k</code>可能最大值。</p><p><strong>示例 1：</strong></p><pre><code>输入：text = &quot;ghiabcdefhelloadamhelloabcdefghi&quot;输出：7解释：我们可以把字符串拆分成 &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：text = &quot;merchant&quot;输出：1解释：我们可以把字符串拆分成 &quot;(merchant)&quot;。</code></pre><h3 id="题解：双指针-贪心"><a href="#题解：双指针-贪心" class="headerlink" title="题解：双指针+贪心"></a>题解：双指针+贪心</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * @param &amp;#123;string&amp;#125; text * @return &amp;#123;number&amp;#125; */</span><span class="token keyword">var</span> longestDecomposition <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> n <span class="token operator">=</span> text<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> j<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        s1 <span class="token operator">+</span><span class="token operator">=</span> text<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        s2 <span class="token operator">=</span> text<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> s2<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s1 <span class="token operator">===</span> s2<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            ans<span class="token operator">++</span><span class="token punctuation">;</span>            s1 <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>            s2 <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">===</span> j<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> ans<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        j<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果无法找到重复子序列，直接返回最小分解数乘以2再加1，表示字符串不能再分解了</span>    <span class="token keyword">return</span> ans <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46. 全排列</title>
      <link href="/2023/04/11/46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2023/04/11/46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * @param &amp;#123;number[]&amp;#125; nums * @return &amp;#123;number[][]&amp;#125; */</span><span class="token keyword">var</span> permute <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">const</span> used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录每个元素是否已被使用过</span>    <span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span>length <span class="token operator">===</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果路径中的元素个数等于 n，表示已经找到一组解</span>            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>path<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将路径中的元素加入结果数组</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果元素未被使用过</span>                path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将其加入路径</span>                used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 标记元素已被使用</span>                <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 继续搜索下一个元素</span>                used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 恢复现场</span>                path<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 回溯</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>递归真难啊</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new start</title>
      <link href="/2023/04/09/new%20start/"/>
      <url>/2023/04/09/new%20start/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h2><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法<strong>。</strong></p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="img"></p><pre><code>输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]输出：[[1,0,1],[0,0,0],[1,0,1]]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="img"></p><pre><code>输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * @param &amp;#123;number[][]&amp;#125; matrix * @return &amp;#123;void&amp;#125; Do not return anything, modify matrix in-place instead. */</span><span class="token keyword">var</span> setZeroes <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>matrix<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> row <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> column <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> rowLen <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">let</span> columnLen <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rowLen<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> columnLen<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                row<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                column<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> row<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        matrix<span class="token punctuation">[</span>row<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> rowLen<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>column<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> matrix<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>10.02日练</title>
      <link href="/2022/10/28/10-02%E6%97%A5%E7%BB%83/"/>
      <url>/2022/10/28/10-02%E6%97%A5%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<p>单链表中的节点应该具有两个属性:val 和 next。<em>val 是当前节点的值</em>,next 是指向下一个节点的指针&#x2F;引用。<a href="https://blog.csdn.net/qq_37264323/article/details/114366943">https://blog.csdn.net/qq_37264323/article/details/114366943</a></p><p>递归</p><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p><p><img src="https://files.catbox.moe/xz4ovx.JPG" alt="img"></p><pre class=" language-C++"><code class="language-C++">class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        if (l1 == nullptr) &#123;            return l2;        &#125;        else if (l2 == nullptr) &#123;            return l1;        &#125;         else if (l1->val < l2->val) &#123;            l1->next = mergeTwoLists(l1->next, l2);            return l1;        &#125;        else &#123;            l2->next = mergeTwoLists(l1, l2->next);            return l2;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Start_here</title>
      <link href="/2022/10/08/Start-here/"/>
      <url>/2022/10/08/Start-here/</url>
      
        <content type="html"><![CDATA[<h1 id="Hi-there-Wish-you-have-a-good-day"><a href="#Hi-there-Wish-you-have-a-good-day" class="headerlink" title="Hi there! Wish you have a good day!"></a>Hi there! Wish you have a good day!</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Start_here </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
